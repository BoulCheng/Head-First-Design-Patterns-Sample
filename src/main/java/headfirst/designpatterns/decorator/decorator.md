# 装饰者模式

- 设计原则
    - 类应该对扩展开放，对修改关闭
    
- 装饰者模式
    - 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
    
- 装饰者和被装饰对象有相同的超类型(超类型可以抽象类或接口)。如果超类型是抽象类那么继承是为了达到“类型匹配”，而不是利用继承获得“行为”。因为装饰者必须能取代被装饰者
- 装饰者组合被装饰者，装饰者有一个实例变量以保存被装饰者的引用，变量类型是超类型.
- 装饰者在被装饰者的行为之前与/或之后，加上自己的行为，以实现动态责任附加的扩展功能

- 所有装饰者共同实现接口(也可以是抽象类). 所有被装饰者也一样
- 装饰者同时也可以成为被装饰者进而被其他装饰者装饰
- 利用装饰者模式，常常造成设计中有大量的小类，并且需要实例化很多类
- 装饰者一般对组件的客户是透 明的，除非客户程序依赖于组 件的具体类型. 使用装饰者模式不能依赖特殊类型执行特殊行为.
- 继承属于扩展形式之一. 除了继承，装饰者模式也可以让我们扩展行为

- 抽象组件 -> 具体组件. 抽象装饰者 -> 具体装饰者
- Java.io


- vs 责任链模式
    - 相同点：都能对对象的处理进行增强
    - 不同点
        - 装饰者模式 持有被装饰的对象，并具备被装饰者的行为，对其行为进行补充增强。装饰者它可以对某一类的对象进行增强，这样就避免了冗余的继承体系，使得扩展性很强
            - 它不关心外界如何调用，只注重对对象功能的加强，
        - 职责链模式，每个被调用者都持有下一个被调用者的引用，客户端只需要发起一次调用即可。核心思想就是分而治之。当调用者面临的被调者太多时，为了降低逻辑复杂度，把相关的被调用者组织起来，形成一个链式的结构，被调用者之间进行调用传递（责任传递）
            - 只关心被调用者之间的调用传递。