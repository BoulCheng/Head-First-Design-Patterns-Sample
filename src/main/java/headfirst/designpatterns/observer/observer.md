# observer

- 出版者+订阅者=观察者模式. 出版者改称为“主题”(Subject)，订阅者改称 为“观察者”(Observer)。

- 观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

- 有“一个”具有状态的主题。另一方面，观察者 使用这些状态，虽然这些状态并不属于他们。有 许多的观察者，依赖主题来告诉他们状态何时改 变了。这就产生一个关系:“一个”主题对“多 个”观察者的关系。

- 因为主题是真正拥有数据的人，观察 者是主题的依赖者，在数据变化时更新，这样比 起让许多对象控制同一份数据来，可以得到更干 净的的OO设计


- 拉或推的区别: 推-主题推给观察者 拉-观察者拉取主题的数据

- 设计原则: 
    - 为了交互对象之间的松耦合设计而 努力。(主题有主题接口，观察者有观察者接口，可以独立地复用主题或观察者，改变主题或观察者其中一方，并不会影响另一方，因为两者是松耦合的)
    
    
- JDK内置的观察者模式

    - 观察者 实现观察者接口(java.uitl.Observer)
    - 可观察者 继承可观察者类java.util.Observable. 然后，需要两个步骤:
        - 先调用setChanged()方法，标记状态已经改变的事实
        - 然后调用两种notifyObservers()方法中的一个:notifyObservers() 或 notifyObservers(Object arg)(当通知时，此版本可以 传送任何的数据对象给 每一个观察者)
    - 如果你想“推”(push)数据给观察者，你可以把数据当作数据对象传送给 notifyObservers(Object arg)方法
    - 否则，观察者就必须从可观察者对象中“拉”(pull)数据. 没有调用notifyObservers()传送数据对象，这表示我们采用的做法是“拉”.
    
    - setChanged()方法可以让你在更新观察者时，有更多的弹性，你可以更 适当地通知观察者。比方说，如果没有setChanged()方法，我们的气象站测量是如此敏锐， 以致于温度计读数每十分之一度就会更新，这会造成WeatherData对象持续不断地通知观察 者，我们并不希望看到这样的事情发生。如果我们希望半度以上才更新，就可以在温度差 距到达半度时，调用setChanged()，进行有效的更新。 你也许不会经常用到此功能，但是把这样的功能准备好，当需要时马上就可以使用。总之， 你需要调用setChanged()，以便通知开始运转。如果此功能在某些地方对你有帮助，你可能 也需要clearChanged()方法，将changed状态设置回false。另外也有一个hasChanged()方法， 告诉你changed标志的当前状态。
    - notifyObservers方法不保证通知的顺序，因 为一旦观察者/可观察者的实现有所改变，通知次序就会改变，很可能就会产生错 误的结果
    - Vector<Observer>

                         
- MVC RMI               
                                        