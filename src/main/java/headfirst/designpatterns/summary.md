

### 设计模式-基本原则

- 开放-关闭原则
    - 可以具有良好的可扩展性，可维护性
    - 能够扩展已存在的系统，能够提供新的功能满足新的需求，因此该软件有着很强的适应性和灵活性
    - 已存在的模块，特别是那些重要的抽象模块，不需要被修改，那么该软件就有很强的稳定性和持久性
    
- 单一职责原则
    - 单一职责原则可以降低类的复杂度，一个类仅负责一项职责，其逻辑肯定要比负责多项职责简单
- 最少知识原则(迪米特法则)
    - 减少对象之间的交互，只和你的密友(直接的朋友)交谈
    - 注意交互的类有哪些以及它们是如何交互的，避免太多的类耦合在一起
    - 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部
    - 实际方针:在某个对象的方法内，只应该调用属于以下范围的方法
        - 该对象本身的方法
        - 被当作方法参数传进来的对象的方法
        - 此方法创建的对象的方法
        - 对象的组件
        
        - 如果A对象是调用B对象的方法返回的结果，不要调用A对象的方法，而应该让B对象去实现对A对象的方法调用
        - 缺点：增加复杂度          
        
- 依赖倒置原则    
    - 要依赖抽象，不要依赖具体类
    - 相比针对接口编程，这个原则更强调抽象，
    - 不能让高层组件依赖低层组件，且高层或低层组件都应该依赖于抽象. 高层组件是有其他低层组件定义其行为的类.
    - 具体产品类依赖抽象产品类-依赖倒置现象
    - 核心思想就是面向接口(抽象)编程
- 接口隔离(分离)原则
    - 接口隔离原则的思想在于建立单一接口，尽可能地去细化接口，接口中的方法尽可能少
    - 避免实现接口的类 因为需要实现该接口去使用需要的方法 而必须要实现其他用不到的方法
    
    
- 组合/聚合复用原则 
    - 在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分; 新的对象通过向这些对象的委派达到复用已有功能的目的
    - 组合或者聚合好过于继承
        - 组合/聚合降低了类与类之间的耦合度
        - 从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性
        - 在面向对象的设计中，如果直接继承基类，会破坏封装，因为继承将基类的实现细节暴露给子类；如果基类的实现发生了改变，则子类的实现也不得不改变；
    - composition vs aggregation
        - composing a new class from existing classes, this concept is called composition (if the composition happens dynamically, it's usually called aggregation)
        - 组合：部分与整体是与生俱来的，部分的存在依赖于整体
- 里氏替换原则
    - 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能
    - 重点在不影响原功能，而不是不覆盖原方法
    - 继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义

### 责任链
- 责任链
    - 一种处理请求的模式，将多个处理器组成一条链，然后让请求在链上传递
        - 找个满足条件handler处理请求
        - 链上每个handler都有机会处理并做一些工作，被称为拦截器（Interceptor）或者过滤器（Filter）
        
        
        
- 模版方法、策略、工厂、单例、观察者、代理、门面、装饰器、适配器、责任链

- 软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的
创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。

- GoF把23个常用模式分为创建型模式、结构型模式和行为型模式三类
    
- 创建型模式包括：
    
    工厂方法：Factory Method
    抽象工厂：Abstract Factory
    建造者：Builder
        - 创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象
    原型：Prototype
        - 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
        - Object#clone
    单例：Singleton
    
    - 结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。
    
- 结构型模式有：
    
    适配器
    桥接
        - 不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能
    组合
    装饰器
    外观
    享元
        - 享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。
        - 享元模式在Java标准库中有很多应用。我们知道，包装类型如Byte、Integer都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以Integer为例，如果我们通过Integer.valueOf()这个静态工厂方法创建Integer实例，当传入的int范围在-128~+127之间时，会直接返回缓存的Integer实例
        ```
        public class Main {
            public static void main(String[] args) throws InterruptedException {
                Integer n1 = Integer.valueOf(100);
                Integer n2 = Integer.valueOf(100);
                System.out.println(n1 == n2); // true
            }
        }
        ```
        - 对于Byte来说，因为它一共只有256个状态，所以，通过Byte.valueOf()创建的Byte实例，全部都是缓存对象。
        - 因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。
        -  总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。
        - 在实际应用中，享元模式主要应用于缓存
        - 享元设计模式是一个类有很多对象，而单例是一个类仅一个对象；享元模式是为了节约内存空间，提升程序性能（避免大量的new操作）；而单例模式则主要是出于共享状态的目的
            - 对象个数：享元模式可以再次创建对象 也可以取缓存对象，单例模式则是严格控制单个进程中只有一个实例对象

    代理        
    
- 行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。
      
      行为型模式有：
      
      责任链
      命令
      解释器
      迭代器
      中介
      备忘录
      观察者
      状态
      策略
      模板方法
      访问者